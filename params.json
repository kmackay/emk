{"name":"emk","tagline":"Build system, written in Python","body":"emk\r\n===\r\n\r\nA Python-based build tool.\r\n\r\nRequires Python 2.6 or higher; Python 3+ is supported. Currently supports OS X, Linux, and Windows.\r\nCompiling and linking module support is provided for gcc/g++ and MSVC.\r\n\r\nFeatures\r\n--------\r\n\r\n * Fast builds. emk is designed to use multiple threads, and uses as many threads as you have processors\r\n   by default. Build time scales linearly with the number of executed build rules.\r\n * No installation required.\r\n * Designed for correct recursive builds (ie, building in multiple directories that are dependent on\r\n   each other). Note that emk only uses a single process for recursive builds; it does not spawn a new\r\n   process for each directory. This allows a global view of the build graph so that correctness is easy.\r\n * Includes a module system for common build rules. Comes with modules for building C, C++, and Java.\r\n * Build rules are written in Python, so anything that Python can do can be done while building. It is\r\n   easy to write new build rules.\r\n * Allows specification of build rules that produce multiple files (eg code generation), as well as rules\r\n   that do not produce any files.\r\n * Allows new build rules to be added after building has started. This allows (for example) autodetection\r\n   of executables based on the compiled object file (by parsing the nm output) rather than trying to parse\r\n   source code.\r\n * Hierarchical build configuration system, so you can configure build settings (such as compiler flags)\r\n   for a given project or directory easily.\r\n * Fancy output formatting system - can output plain text, coloured/styled console output (using ANSI escape codes),\r\n   or HTML (suitable for CSS styling).\r\n\r\nInstallation\r\n------------\r\n\r\nIf desired, you can run `(sudo) setup.py install` to create a symlink at /usr/bin/emk pointing to\r\nthe emk script in the current directory (on *nix platforms) or add it to the PATH (on Windows). You\r\ncan run `(sudo) setup.py uninstall` to remove /usr/bin/emk if it is a symlink to the emk script in\r\nthe current directory (on *nix platforms), or to remove it from the PATH (on Windows).\r\n\r\nNote that emk does not require installation; it can be run directly from any directory. The only requirement\r\nis that the emk script and the emk.py module must be in the same directory. Typically that directory\r\nwould also contain a 'modules' directory containing the various emk modules, and optionally a 'config'\r\ndirectory containing the global configuration (emk_global.py) for the emk instance.\r\n\r\nDocumentation\r\n-------------\r\n\r\nRun `emk -h` for basic usage information.\r\n\r\n**[Tutorial](tutorial/tutorial.md)**  \r\n**[Manual](docs/manual.md)**\r\n### Modules\r\n * [Utility Module](docs/modules/utils.md)\r\n * [C/C++ Module](docs/modules/c.md)\r\n * [Link Module](docs/modules/link.md)\r\n * [Java Module](docs/modules/java.md)\r\n\r\nThere are also docstrings with detailed documentation for all public API functions/properties in the emk source code.\r\n\r\nPerformance\r\n-----------\r\n\r\nHere is a graph of build time vs number of files compiled:\r\n\r\n![Graph of build time vs number of files to compile, showing the linear relationship](docs/images/speed.png)\r\n\r\nNote the linear relationship. There is some bumpiness which is probably due to filesystem caching effects.\r\nThis test involved emk autodiscovering and compiling a set of generated C files. Each C file contains one function,\r\nand includes a header that is specific to that C file, a header that is shared amongst groups of 100 C files, and a global\r\nheader that is shared by all C files. The C files are divided into directories each containing 1000 C files; this is to\r\navoid some performance issues with HFS+ when directories contain large numbers of files.\r\n\r\nYou can reproduce these results using the scripts in the `speed-test` directory. First, change to the `speed-test` directory.\r\nThen, run `./generate.py` to generate the test files. Once that is complete, run `./run.py` to run the speed test. This will take\r\na long time. Once the speed test is completed, the results will be in `results.txt`. Each line of the results is\r\n`<number of files compiled> <build time in seconds>`. You can then run `./cleanup.py` to remove the generated test files.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}